ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Вова пообещал себе больше никогда не играть в игры... Но недавно компания Firestorm выпустила очень популярную игру — World of Farcraft, и Вова, конечно же, начал в неё играть.

Он впал в ступор при выполнении очередного квеста — необходимо было прийти в поселение Надгород и распространить там слух.

Вова знает, что в Надгороде живут n персонажей. Некоторые персонажи дружат между собой и готовы делиться информацией друг с другом. Также он знает, что i-й персонаж готов начать распространять слух за ci золота. Как только персонаж узнаёт слух, он рассказывает его всем своим друзьям, которые, в свою очередь, тоже начинают распространять этот слух (но уже бесплатно).

Вова хочет, чтобы слух узнали все n персонажей Надгорода. За какое минимальное количество золота он сможет это сделать?

Посмотрите примечание для лучшего понимания задачи.

Входные данные
В первой строке входных данных задано два целых числа n и m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105) — количество людей в Надгороде и количество дружеских связей между ними.

В следующей строке входных данных заданы n целых чисел ci (0 ≤ ci ≤ 109) — количество золота, за которое i-й персонаж готов начать распространять слух.

В следующих m строках заданы пары (xi, yi), обозначающие, что персонажи xi и yi дружат (1 ≤ xi, yi ≤ n, xi ≠ yi). Гарантируется, что никакая пара дружащих персонажей не повторяется.

Выходные данные
Выведите единственное число — минимальное количество золота, за которое Вова сможет выполнить квест.



#include<bits/stdc++.h>

using namespace std;

int n;
long long countt = 1LL * 0;
vector <vector<int> > g(100000);
int arr[100000];
vector <int> used(1000000);
vector<int> comp;

void dfs (int v) {
	used[v] = 1;
	comp.push_back (v);
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (! used[to])
			dfs (to);
	}
}

void find_comps() {
    vector<int> ans;
	for (int i=0; i<n; ++i)
		used[i] = 0;
	for (int i=0; i<n; ++i)
		if (! used[i]) {
			comp.clear();
			dfs (i);

			for (int j=0; j<comp.size(); ++j)
            {
                ans.push_back(arr[comp[j]]);
            }
            sort(ans.begin(), ans.end());
            countt = 1LL * countt + ans[0];
            ans.clear();



		}

}

int main() {

    int m, x, y, l;
    cin >> n;
    cin >> m;
    for (int i = 0; i < n; i++)
        cin >> arr[i];
    for (int i = 0; i < m; i++){
        cin >> x;
        cin >> y;
        g[x - 1].push_back(y - 1);
        g[y - 1].push_back(x - 1);
    }
    find_comps();
    cout << countt;

    return 0;
}
