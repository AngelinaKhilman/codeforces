ограничение по времени на тест2 seconds
ограничение по памяти на тест256 megabytes
вводстандартный ввод
выводстандартный вывод
Правительство Берляндии решило улучшать отношения с соседними странами. В первую очередь было решено построить новые дороги так чтобы из всех городов Берляндии и соседних стран можно было добраться до всех остальных. Всего в Берляндии и соседних странах n городов и ровно n - 1 двусторонних дорог. Из-за недавнего финансового кризиса правительство Берляндии сильно стеснено в средствах, поэтому чтобы построить новую дорогу оно вынуждено закрывать какую-то из существующих. Каждый день можно закрыть одну существующую дорогу и сразу же построить новую. Ваша задача — определить, сколько дней потребуется для перестройки дороги так, чтобы из любого города можно было добраться до любого другого, а так же составить план закрытия старых и постройки новых дорог.

Входные данные
В первой строке записано целое число n (2 ≤ n ≤ 1000) — число городов в Берляндии и соседних странах. Далее в n - 1 строках записаны описания дорог. Каждая дорога описывается двумя целыми числами ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi) — пара городов, которые дорога соединяет. Между каждой парой городов не может быть больше одной дороги, никакая дорога не соединяет город сам с собой.

Выходные данные
Выведите ответ на задачу, число t — какое наименьшее число дней потребуется, чтобы перестроить дороги так чтобы из любого города можно было добраться до любого другого. Далее выведите t строк — план закрытия старых и постройки новых дорог. Каждая строка должна описывать действия в очередной день в формате i j u v — означает, что нужно закрыть дорогу между городами i и j и построить дорогу между городами u и v. Города нумеруются начиная с 1. Если решений несколько, выведите любое.


#include<bits/stdc++.h>

using namespace std;

int n;
vector <vector<int> > g(1000);
vector < vector <int > > w;
vector <int> used(1000);
vector<int> comp;
vector<int> p;
vector <pair < int, int > > qwe;

void dfs (int v, int p = -1) {
	used[v] = 1;
	comp.push_back (v);
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
        if (to == p)
            continue;
		if (! used[to])          
            dfs (to, v);
        else if(v < g[v][i])
            qwe.push_back(make_pair(v + 1, g[v][i] + 1));
            
            
	}
}

void find_comps() {
    vector<int> ans;
    p.assign (n, -1);
	for (int i=0; i<n; ++i)
		used[i] = 0;
	for (int i=0; i<n; ++i)
		if (! used[i]) {
			comp.clear();
			dfs (i);

			for (size_t j=0; j<comp.size(); ++j)
            {
                 ans.push_back(comp[j]);
            }
            w.push_back(ans);
            ans.clear();




		}

}

int main() {
    vector <pair <int, int> > otv;
    cin >> n;
    int x, y;
    for (int i = 0; i < n - 1; i++){
        cin >> x;
        cin >> y;
        g[x - 1].push_back(y - 1);
        g[y - 1].push_back(x - 1);
    }
    find_comps();

    cout << w.size() - 1 << endl;
    if (w.size() > 1){
        for (size_t i = 0; i < w.size() - 1; i++){
        otv.push_back(make_pair(w[i][0] + 1, w[i + 1][0] + 1));
    }
    }

     for (size_t i = 0; i < otv.size(); i++){
         cout << qwe[i].first << " " << qwe[i].second << " ";
         cout << otv[i].first << " " << otv[i].second;
         cout << endl;
     }


    return 0;
}
