ограничение по времени на тест2 секунды
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Лиса Ciel собирается опубликовать статью по ЛИС (Лисооперируемым Интеллектуальным Системам). Она слышала, что список авторов научной статьи всегда сортируется в лексикографическом порядке.

После изучения примеров оформления, лиса обнаружила, что иногда это утверждение не верно. В некоторых статьях имена авторов не сортируются в лексикографическом порядке в обычном понимании. Но, оказывается, верно то, что после некоторого изменения порядка букв в алфавите, порядок авторов становится лексикографическим!

Лиса хочет знать, существует ли такой порядок букв латинского алфавита, что имена авторов предлагаемой ею статьи следуют в лексикографическом порядке. Если да, то требуется также найти любой такой порядок.

Лексикографический порядок определяется следующим образом. Мы сравниваем s и t, сперва находя крайнюю левую позицию с различающимися символами: si ≠ ti. Если такой позиции нет (то есть, s — это префикс t или наоборот), то более короткая строка меньше. В противном случае мы сравниваем символы si и ti согласно их порядку в алфавите.

Входные данные
В первой строке записано целое число n (1 ≤ n ≤ 100), количество имен.

В каждой из следующих n строк записано по одному слову namei (1 ≤ |namei| ≤ 100), обозначающему i-е имя. Каждое имя содержит только строчные буквы латинского алфавита. Все имена различны.

Выходные данные
Если существует такой порядок букв, при котором имена в данном списке следуют в лексикографическом порядке, выведите любой такой порядок в виде перестановки символов 'a'–'z' (иными словами, выведите сначала первую букву модифицированного алфавита, затем вторую, и так далее).

В противном случае выведите единственное слово «Impossible» (без кавычек).


g = []
used = []
ans = []
flagok = True


def dfs(v, p=-1):
    global ans, used
    used[v] = 2
    global flagok
    for i in range(len(g[v])):
        to = g[v][i]
        if used[to] == 0:
            dfs(to, v)
        elif used[to] == 2:
            flagok = False
    used[v] = 1
    ans.append(v)


def topsort():
    global ans, used
    for i in range(26):
        used[i] = 0
    ans = []
    for i in range(26):
        if used[i] == 0:
            dfs(i)
    ans.reverse()


def main():
    alph = "abcdefghijklmnopqrstuvwxyz"
    global flagok
    answer = []
    n = int(input())
    a = []
    for i in range(n):
        s = input()
        a.append(s)
    flag = True
    for i in range(26):
        g.append([])
        used.append(0)
    for i in range(n):
        for r in range(i + 1, n):
            if len(a[i]) < len(a[r]):
                m = len(a[i])
            else:
                m = len(a[r])
            for j in range(m):
                if a[i][j] != a[r][j]:
                    g[alph.index(a[i][j])].append(alph.index(a[r][j]))
                    break
                if j == m - 1 and a[i][j] == a[r][j]:
                    if len(a[i]) > len(a[r]):
                        flag = False
                        break

   
    topsort()
    if flag == False or flagok == False:
        print("Impossible")
    else:
        for i in range(len(ans)):
            answer.append(alph[(ans[i])])
        print(''.join([str(x) for x in answer]))


if __name__ == "__main__":
    main()
