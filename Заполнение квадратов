ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Вам заданы две матрицы A и B. В каждой матрице ровно n строк и m столбцов. Каждый элемент A — 0 или 1; каждый элемент B изначально равен 0.

Вы можете провести любое количество операций с матрицей B. Для проведения операции вы должны выбрать любую подматрицу B размера 2×2 и заменить все элементы в этой подматрице на 1. Иными словами, вы выбираете два целых числа x и y (1≤x<n, 1≤y<m), а затем заменяете все элементы Bx,y, Bx,y+1, Bx+1,y и Bx+1,y+1 на 1.

Ваша задача — сделать матрицу B равной матрице A. Две матрицы A и B равны тогда и только тогда, когда каждый элемент матрицы A равен соответствующему элементу матрицы B.

Можно ли сделать матрицы равными? Если это так, вы должны найти последовательность операций, которые делают матрицу B равной матрице A. Обратите внимание, что минимизировать количество операций не нужно.

Входные данные
В первой строке записаны два целых числа n и m (2≤n,m≤50).

Затем следуют n строк, в каждой по m целых чисел. j-е число в i-й строке — Ai,j. Каждое число равно либо 0, либо 1.

Выходные данные
Если невозможно сделать B равной A, выведите одно число −1.

Иначе выведите любую последовательность операций, превращающую B в A, в следующем формате: в первой строке выведите одно целое число k — количество операций, а затем выведите k строк, в каждой из которых должны быть два целых числа x и y для соответствующей операции (заменить все элементы Bx,y, Bx,y+1, Bx+1,y и Bx+1,y+1 на 1). Должно выполняться условие 0≤k≤2500.

#include <bits/stdc++.h>

using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    int n, m;
    cin >> n;
    cin >> m;
    vector <vector<int> > v(n, vector <int> (m));
    vector <vector<int> > v1(n, vector <int> (m));
    vector <pair <int, int> > v2;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            cin >> v[i][j];
        }
    }
    int ans = 0;
    int flag = 0;
    for (int i = 0; i < n - 1; i++){
        for (int j = 0; j < m - 1; j++){
            if (v[i][j] == 1 && v[i + 1][j] == 1 && v[i + 1][j + 1] == 1 && v[i][j + 1] == 1){
                ans += 1;
                v2.push_back(make_pair(i + 1, j + 1));
                v1[i][j] = 1;
                v1[i + 1][j] = 1;
                v1[i + 1][j + 1] = 1;
                v1[i][j + 1] = 1;
            }
            if (v[i][j] == 1){
                flag = 1;
            }
        }
    }
    int flag1 = 0;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < m; j++){
            if (v1[i][j] != v[i][j]){
                flag1 = 1;
                break;
            }
        }
    }
    if (ans > 0 && flag1 == 0){
        cout << ans << endl;
    for (int i = 0; i < v2.size(); i++){
        cout << v2[i].first << " " << v2[i].second << endl;
    }
    }
    if (flag1 == 1){
        cout << -1 << endl;
    }
    if (ans == 0 && flag1 == 0){
        cout << 0 << endl;
    }

  return 0;
}
